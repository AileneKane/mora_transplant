sigma.psiAB[g]~dunif(0,10)#temporal variance for veg plants transition to rep
tau.psiAB[g]<-pow(sigma.psiAB[g],-2)
sigma.psiAB2[g]<-pow(sigma.psiAB[g],2)
sigma.psiBA[g]~dunif(0,10)#temporal variance for rep plants transition to veg
tau.psiBA[g]<-pow(sigma.psiBA[g],-2)
sigma.psiBA2[g]<-pow(sigma.psiBA[g],2)
sigma.pA[g]~dunif(0,10)#temporal variance for veg plants recapture (emergence)
tau.pA[g]<-pow(sigma.pA[g],-2)
sigma.pA2[g]<-pow(sigma.pA[g],2)
sigma.pB[g]~dunif(0,10)#temporal variance for rep plants recapture (emergence)
tau.pB[g]<-pow(sigma.pB[g],-2)
sigma.pB2[g]<-pow(sigma.pB[g],2)
beta.phiA[g]~dnorm(0,0.001)I(-10,10)
beta.phiB[g]~dnorm(0,0.001)I(-10,10)
beta.psiAB[g]~dnorm(0,0.001)I(-10,10)
beta.psiBA[g]~dnorm(0,0.001)I(-10,10)
beta.pA[g]~dnorm(0,0.001)I(-10,10)
beta.pB[g]~dnorm(0,0.001)I(-10,10)
beta1.phiA[g]~dnorm(0,0.001)I(-10,10)
beta1.phiB[g]~dnorm(0,0.001)I(-10,10)
beta1.psiAB[g]~dnorm(0,0.001)I(-10,10)
beta1.psiBA[g]~dnorm(0,0.001)I(-10,10)
beta1.pA[g]~dnorm(0,0.001)I(-10,10)
beta1.pB[g]~dnorm(0,0.001)I(-10,10)
#calculate probabilities of four differnt groups to look at later...
logit(phiA0[g])<- mu.phiA[g]
logit(phiA1[g])<- mu.phiA[g] + beta.phiA[g]
logit(phiB0[g])<- mu.phiB[g]
logit(phiB1[g])<- mu.phiB[g] + beta.phiB[g]
logit(psiA0[g])<- mu.psiAB[g]
logit(psiA1[g])<- mu.psiAB[g] + beta.psiAB[g]
logit(psiB0[g])<- mu.psiBA[g]
logit(psiB1[g])<- mu.psiBA[g] + beta.psiBA[g]
logit(pA0[g])<- mu.pA[g]
logit(pA1[g])<- mu.pA[g] + beta.pA[g]
logit(pB0[g])<- mu.pB[g]
logit(pB1[g])<- mu.pB[g] + beta.pB[g]
}#g
# Define state-transition and observation matrices
for (i in 1:nind){
# Define probabilities of state S(t+1) given S(t)
for (t in f[i]:(n.occasions-1)){
ps[1,i,t,1] <- phiA[i,t] * (1-psiAB[i,t])
ps[1,i,t,2] <- phiA[i,t] * psiAB[i,t]
ps[1,i,t,3] <- 1-phiA[i,t]
ps[2,i,t,1] <- phiB[i,t] * psiBA[i,t]
ps[2,i,t,2] <- phiB[i,t] * (1-psiBA[i,t])
ps[2,i,t,3] <- 1-phiB[i,t]
ps[3,i,t,1] <- 0
ps[3,i,t,2] <- 0
ps[3,i,t,3] <- 1
# Define probabilities of O(t) given S(t) ##first coumn is observed state, last is true state
po[1,i,t,1] <- pA[i,t]
po[1,i,t,2] <- 0
po[1,i,t,3] <- 1-pA[i,t]
po[2,i,t,1] <- 0
po[2,i,t,2] <- pB[i,t]
po[2,i,t,3] <- 1-pB[i,t]
po[3,i,t,1] <- 0
po[3,i,t,2] <- 0
po[3,i,t,3] <- 1
} #t
} #i
# Likelihood
for (i in 1:nind){
# Define latent state at first capture
z[i,f[i]] <- y[i,f[i]]
for (t in (f[i]+1):n.occasions){
# State process: draw S(t) given S(t-1)
z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
# Observation process: draw O(t) given S(t)
y[i,t] ~ dcat(po[z[i,t], i, t-1,])
} #t
} #i
}
",fill = TRUE)
sink()
#Function
known.state.ms <- function(ch){##removes 3s and replaces them with NAs, and replaces first observation with NA
state <- ch
for (i in 1:dim(ch)[1]){
n1 <- min(which(ch[i,]<3))#
state[i,n1] <- NA
}
state[state==3] <- NA
return(state)
}
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 1 or 2 to all unknown states
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
n1 <- min(which(ch[i,]<3))#
states <- max(ch, na.rm = TRUE)
known.states <- 1:(states-1)
v <- which(ch==states)#which occurences are unknown states (=3)
ch[-v] <- NA#everyhing else besides the 3s gets an NA
ch[v] <- sample(known.states, length(v), replace = TRUE)##gives all unseen occurrences (3s) a starting value that is a random sampling of either 1 or 2
#ch[i,n1] <- NA#make first observance an NA (ot a 3)
return(ch)
}
#Function to create initial values for unknown z
# Initial values
# Note that all initial values of the unknown z must all be 3 (not 1 or 2). Therefore the function ms.init.z needs some slight changes?
# Function to create initial values for unknown z
#ms.init.z2 <- function(ch, f){
#  for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
#  states <- max(ch, na.rm = TRUE)
#  known.states <- 1:(states-1)
#  v <- which(ch==states)
#  ch[-v] <- NA
#  ch[v] <- states
#  return(ch)
#}
#zst2=ms.init.z2(ch,f)
ch=isoall_CH.ms
y = isoall_CH.ms
y[73,24]=NA
zst1=ms.init.z(ch,f)
# made this change: set interior missing values for the zst to 3
zst3 = ms.init.z(ch, f)
#for(i in 1:nrow(zst3)){
# zst3[i,is.na(y[i,]) ]<- 3
#  zst3[i,1:f[i]]<- NA
#}
#fixes necessary to get model to run with zst1:
zst1[4,24:31]<-NA
zst1[6,24:31]<-NA
zst1[5,24:31]<-NA
zst1[60,31]<-NA
#zst1[73,25:26]<-NA
zst1[119,21:31]<-NA
# Bundle data
jags.data <- list(y = isoall_CH.ms, f = f, n.occasions = dim(isoall_CH.ms)[2], nind = dim(isoall_CH.ms)[1], z = known.state.ms(isoall_CH.ms), group=group, x=time_log, x1=logged_yrs2)
# Initial values
inits<-function(){list(mean.phiA=c(.5,.5), mean.phiB=c(.5,.5),mean.psiAB=c(.5,.5),mean.psiBA=c(.5,.5),mean.pA=c(.5,.5),mean.pB=c(.5,.5),sigma.phiB=c(1,1),sigma.psiAB=c(1,1),sigma.psiBA=c(1,1),sigma.pA=c(1,1),sigma.pB=c(1,1),z = zst1)}#Error in jags.model(file = model.file, data = data, inits = inits, n.chains = n.chains,  : #Error in node y[1,3]
#Observed node inconsistent with unobserved parents at initialization.
#Try setting appropriate initial values.
# Parameters monitored"
parameters <- c("mean.phiA","mean.phiB", "mean.psiAB","mean.psiBA","mean.pA","mean.pB","beta.phiA","beta.phiB", "beta.pA", "beta.pB", "beta.psiAB","beta.psiBA","phiA0","phiA1","phiB0","phiB1","psiA0","psiA1","psiB0","psiB1","pA0","pA1","pB0","pB1","beta1.phiA","beta1.phiB", "beta1.pA", "beta1.pB", "beta1.psiAB","beta1.psiBA","mu.phiA","mu.phiB","mu.pA","mu.pB","mu.psiAB","mu.psiBA","sigma.phiA2","sigma.phiB2","sigma.pA2","sigma.phiB2","sigma.psiAB2","sigma.psiBA2")
# MCMC settings
ni <- 28000
nt <- 10
nb <- 2800
nc <- 4
ms.rf3a <- jags(jags.data, inits, parameters, "ms-ranef3a.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=TRUE, n.cores=2)
library(lme4)
setwd("~/GitHub/radcliffe/Analyses")
expclim<-read.csv("gddchill/expclim.wchillgdd.csv", header=T)
head(expclim)
unique(expclim$temptreat)
##want to plot "0" compared to "ambient" in each site
##select out just these two treatments for now
expclim_controls<-expclim[expclim$temptreat=="0" | expclim$temptreat=="ambient", ]
expclim_controls$temptreat<-factor(expclim_controls$temptreat)
unique(expclim_controls$site)
sitesums<-data.frame(tapply(expclim_controls$soiltemp1_mean,list(expclim_controls$site,expclim_controls$temptreat),length))
colnames(sitesums)<-c("sham.control","ambient")
sites_con<-rownames(sitesums)[!is.na(sitesums$sham.control) & !is.na(sitesums$ambient)]
sites_con<-sites_con[-which(sites_con=="chuine")]
expclim_cont<-expclim_controls[expclim_controls$site %in% sites_con,]
unique(expclim_cont$site)
head(expclim_cont)
#make figures of sham controls vs. ambient conditions:
#mean soil temp:
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_mean))==1){next}
boxplot(dat$soiltemp1_mean~dat$temptreat, main=paste(sites_con[i]), ylab="Mean soil temp")
}
mod2<-lmer(soiltemp1_mean~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs2<-data.frame(coef(summary(mod2)))
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_min))==1){next}
boxplot(dat$soiltemp1_min~dat$temptreat, main=paste(sites_con[i]), ylab="Min soil temp")
}
mod3<-lmer(soiltemp1_min~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs3<-data.frame(coef(summary(mod3)))
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_max))==1){next}
boxplot(dat$soiltemp1_max~dat$temptreat, main=paste(sites_con[i]), ylab="Min soil temp")
}
mod4<-lmer(soiltemp1_max~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs4<-data.frame(coef(summary(mod4)))
soil_difs<-c(coefs2[2,1],coefs4[2,1],coefs3[2,1])
#plot.new()
#mtext(coefs)
#looks like soil temperatures are colder in the shams
####Now mean air temp (for the 4 sites that have this)
quartz(height=4, width=8)
par(mfrow=c(1,4))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$airtemp_mean))==1){next}
boxplot(dat$airtemp_mean~dat$temptreat, main=paste(sites_con[i]), ylab="Mean air temp")
}
quartz(height=4, width=8)
par(mfrow=c(1,4))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$airtemp_min))==1){next}
boxplot(dat$airtemp_min~dat$temptreat, main=paste(sites_con[i]), ylab="Min air temp")
}
quartz(height=4, width=8)
par(mfrow=c(1,4))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$airtemp_max))==1){next}
boxplot(dat$airtemp_max~dat$temptreat, main=paste(sites_con[i]), ylab="Max air temp")
}
#looks like air temperatures are WARMER in the shams
expclim_cont$temptreat <- relevel(as.factor(expclim_cont$temptreat), ref = "ambient")
mod_air<-lmer(airtemp_mean~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs_air<-data.frame(coef(summary(mod_air)))
print(coef(summary(mod_air)))
#Do we see the same patters for max and min values? OR are these altered in different ways
mod_max<-lmer(airtemp_max~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs_max<-data.frame(coef(summary(mod_max)))
mod_min<-lmer(airtemp_min~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs_min<-data.frame(coef(summary(mod_min)))
coefs_max
coefs_min
air_difs<-c(coefs_air[2,1], coefs_min[2,1], coefs_max[2,1])
amb_shamdifs<-rbind(round(soil_difs, digits=3),round(air_difs, digits=3))
colnames(amb_shamdifs)<-c("mean","min","max")
rownames(amb_shamdifs)<-c("soiltemp","airtemp")
##look at differences by site, to see if there are relationships by warming type. perhaps add this interaction?
ranef(mod2)
fixef(mod2)
coef(mod2)
#to do this, include random slope too:
expclim_cont$temptreat <- relevel(as.factor(expclim_cont$temptreat), ref = "ambient")
mod2a<-lmer(soiltemp1_mean~temptreat + (temptreat|site), data=expclim_cont, REML=FALSE)
summary(mod2a)
coef(mod2a)
mod_air<-lmer(airtemp_mean~temptreat + (temptreat|site), data=expclim_cont, REML=FALSE)
coefs_air<-data.frame(coef(summary(mod_air)))
summary(mod_air)
coef(mod_air)
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_mean))==1){next}
boxplot(dat$soiltemp1_mean~dat$temptreat, main=paste(sites_con[i]), ylab="Mean soil temp")
}
mod2<-lmer(soiltemp1_mean~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs2<-data.frame(coef(summary(mod2)))
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_min))==1){next}
boxplot(dat$soiltemp1_min~dat$temptreat, main=paste(sites_con[i]), ylab="Min soil temp")
}
mod3<-lmer(soiltemp1_min~temptreat + (1|site), data=expclim_cont, REML=FALSE)
coefs3<-data.frame(coef(summary(mod3)))
quartz(height=4, width=8)
par(mfrow=c(1,5))
for (i in 1:length(sites_con)){
dat<-expclim_cont[expclim_cont$site==sites_con[i],]
if(length(unique(dat$soiltemp1_max))==1){next}
boxplot(dat$soiltemp1_max~dat$temptreat, main=paste(sites_con[i]), ylab="Max soil temp")
}
table(tempdifs)
soiltemp<-c(-0.425,-0.572,-0.346)
airtemp<-c(0.373,0.388,0.358)
tempdifs<-rbind(soiltemp,airtemp)
colnames(tempdivs<-c("mean","min","max"))
table(tempdifs)
soiltemp<-c(-0.425,-0.572,-0.346)
airtemp<-c(0.373,0.388,0.358)
tempdifs<-rbind(soiltemp,airtemp)
tempdifs<-as.table(rbind(soiltemp,airtemp))
tempdifs
colnames(tempdivs<-c("mean","min","max"))
colnames(tempdifs<-c("mean","min","max"))
table(tempdifs)
print(tempdifs)
soiltemp<-c(-0.425,-0.572,-0.346)
airtemp<-c(0.373,0.388,0.358)
tempdifs<-as.table(rbind(soiltemp,airtemp))
colnames(tempdifs)<-c("mean","min","max"))
print(tempdifs)
@
soiltemp<-c(-0.425,-0.572,-0.346)
airtemp<-c(0.373,0.388,0.358)
tempdifs<-as.table(rbind(soiltemp,airtemp))
colnames(tempdifs)<-c("mean","min","max"))
print(tempdifs)
colnames(tempdifs)<-c("mean","min","max"))
colnames(tempdifs)<-c("mean","min","max")
print(tempdifs)
setwd("~/GitHub/mora_transplant")
etwd("~/GitHub/mora_transplant")
setwd("~/GitHub/mora_transplant")
library(car)
library(lme4)
library(boot)
library(multcomp)
library(survival)
library(RColorBrewer)
update.packes()
update.packages()
library(KMsurv)
transdat<-read.csv("analyses/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
setwd("~/GitHub/mora_transplant")
library(car)
library(lme4)
library(boot)
library(survival)
library(RColorBrewer)
#install.packages('KMsurv')
#install.packages("interval")
library(KMsurv)
library(interval)
update.packages()
transdat<-read.csv("analyses/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
update.packages()
setwd("~/GitHub/mora_transplant")
library(car)
library(lme4)
library(boot)
library(survival)
library(RColorBrewer)
#install.packages('KMsurv')
#install.packages("interval")
library(KMsurv)
library(interval)
update.packages()
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
setwd("~/GitHub/mora_transplant")
library(car)
library(lme4)
library(boot)
library(survival)
library(RColorBrewer)
#install.packages('KMsurv')
#install.packages("interval")
library(KMsurv)
install.packages('KMsurv')
library(KMsurv)
library(interval)
install.packages("interval")
library(interval)
update.packages()
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
setwd("~/GitHub/mora_transplant/analyses")
setwd("~/GitHub/mora_transplant/data")
transdat<-read.csv("2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
transdat<-read.csv("2013TransplantStatusHeight(October)_surv.csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
setwd("~/GitHub/mora_transplant")
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
head(transdat)
dim(transdat)#3959 individuals, 39 columns
head(transdat)
tail(transdat)
transdat2=merge(transdat,microclim,by.x=c("PlantedStand","Block","Canopy","Understory"),by.y=c("Elevation_m","Block","Canopy","Understory"),all = TRUE)#this includes all plants, without matches in past/future, as well
microclim=read.csv("data/AllStands_clim1.csv", header=T)#this is just data from 2012; need to update to be average across all years of data
head(microclim)
dim(transdat)
dim(microclim)
transdat2=merge(transdat,microclim,by.x=c("PlantedStand","Block","Canopy","Understory"),by.y=c("Elevation_m","Block","Canopy","Understory"),all = TRUE)#this includes all plants, without matches in past/future, as well
dim(transdat2)
head(transdat2)
transdat=transdat2
transdat$PlantedStand2<-as.numeric(transdat$PlantedStand)
transdat$PlantedStand<-as.factor(transdat$PlantedStand)
transdat$OriginStand<-as.factor(transdat$OriginStand)
transdat$Block<-as.factor(transdat$Block)
transdat$UniqueID<-as.factor(transdat$UniqueID)
transdat$Date1<-as.Date(transdat$Date1,format='%m/%d/%Y')
transdat$Date2<-as.Date(transdat$Date2,format='%m/%d/%Y')
transdat$Date3<-as.Date(transdat$Date3,format='%m/%d/%Y')
head(transdat$Date1)
head(transdat)
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
dim(transdat)
head(transdat)
transdat<-read.csv("data/2013TransplantStatusHeight(October).csv", header=TRUE)#csv file has been sorted so that all dates appear together, all status columns are together, etc
head(transdat)
dim(transdat)
microclim=read.csv("data/AllStands_clim1.csv", header=T)#this is just data from 2012; need to update to be average across all years of data
head(microclim)
dim(transdat)
dim(microclim)#136 rows, 15 columns
transdat2=merge(transdat,microclim,by.x=c("PlantedStand","Block","Canopy","Understory"),by.y=c("Elevation_m","Block","Canopy","Understory"),all = TRUE)#this includes all plants, without matches in past/future, as well
dim(transdat2)
head(transdat2)
transdat$PlantedStand2<-as.numeric(transdat$PlantedStand)
transdat$PlantedStand<-as.factor(transdat$PlantedStand)
transdat$OriginStand<-as.factor(transdat$OriginStand)
transdat$Block<-as.factor(transdat$Block)
transdat$UniqueID<-as.factor(transdat$UniqueID)
transdat$Date1<-as.Date(transdat$Date1,format='%m/%d/%Y')
transdat$Date2<-as.Date(transdat$Date2,format='%m/%d/%Y')
transdat$Date3<-as.Date(transdat$Date3,format='%m/%d/%Y')
transdat$Date4<-as.Date(transdat$Date4,format='%m/%d/%Y')
transdat$Date5<-as.Date(transdat$Date5,format='%m/%d/%Y')
transdat$CompAmt.1<-as.factor(transdat$CompAmt.1)
##add columns for relative growth rate and annual relative growth rate
transdat$rgr=NA
transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$rgr=(transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$Height2-transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$Initial.Height)/transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$Initial.Height#rgr for plants that only survived 1 year
transdat[which(is.na(transdat$HeightDate5)&transdat$HeightDate4>0),]$rgr=(transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$HeightDate4-transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$Initial.Height)/transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$Initial.Height#rgr for plants that survived 2 years
transdat[which(transdat$HeightDate5>0),]$rgr=(transdat[which(transdat$HeightDate5>0),]$HeightDate5-transdat[which(transdat$HeightDate5>0),]$Initial.Height)/transdat[which(transdat$HeightDate5>0),]$Initial.Height#rgr for plants that survived 3 years
#also try just height increment/yr
transdat$hi=NA
transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$hi=(transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$Height2-transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$Initial.Height)#height incr for plants that only survived 1 year
transdat[which(is.na(transdat$HeightDate5)&transdat$HeightDate4>0),]$hi=(transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$HeightDate4-transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$Initial.Height)#height incr. for plants that survived 2 years
transdat[which(transdat$HeightDate5>0),]$hi=(transdat[which(transdat$HeightDate5>0),]$HeightDate5-transdat[which(transdat$HeightDate5>0),]$Initial.Height)#height incr for plants that survived 3 years
#create column for annual rgr and annual hi
transdat$yrs=NA
transdat$annrgr=NA
transdat$annhi=NA
#first, identify # of yrs over which growth meaured
transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),]$yrs=rep(1,times=dim(transdat[which(is.na(transdat$HeightDate4)& transdat$Height2>0),])[1])
transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),]$yrs=rep(2,times=dim(transdat[which(is.na(transdat$HeightDate5)& transdat$HeightDate4>0),])[1])
transdat[which(transdat$HeightDate5>0),]$yrs=rep(3,times=dim(transdat[which(transdat$HeightDate5>0),])[1])
head(transdat)
tail(transdat)
transdat$finalrgr=(transdat$RtCrnHeightDate5-transdat$Initial.Height)/transdat$Initial.Height
transdat$annrgr=transdat$rgr/transdat$yrs
transdat$annhi=transdat$hi/transdat$yrs
tail(transdat)
head(transdat)
transdat$finalrgr=(transdat$RtCrnHeightDate5-transdat$Initial.Height)/transdat$Initial.Height
transdat$annrgr=transdat$rgr/transdat$yrs
transdat$annhi=transdat$hi/transdat$yrs
#Add column for survival data  (0=alive, 1=dead)
transdat$Death=NA
transdat[which(transdat$StatusDate5==0),]$Death=1
transdat[which(transdat$StatusDate5==1),]$Death=0
head(transdat)
transdat[which(transdat$StatusDate2==0&transdat$StatusDate3==1),]
transdat[which(transdat$StatusDate3==0&transdat$StatusDate4==1),]
transdat[which(transdat$StatusDate4==0&transdat$StatusDate5==1),]#all fixed now!
#Add column for time to death in days
transdat$StartDate=as.Date("9/1/2010",format='%m/%d/%Y')
transdat$StartDateDate5=transdat$Date5-transdat$StartDate
transdat$StartDateDate4=transdat$Date4-transdat$StartDate
transdat$StartDateDate3=transdat$Date3-transdat$StartDate
transdat$StartDateDate2=transdat$Date2-transdat$StartDate
transdat$StartDateDate1=transdat$Date1-transdat$StartDate
DaysDeath<-c()
alltime1<-c()
alltime2<-c()
for (i in 1:dim(transdat)[1]){
if(transdat$StatusDate5[i]==1)inddd<-transdat$StartDateDate5[i]
if(transdat$StatusDate5[i]==0 & transdat$StatusDate4[i]==1) inddd<-transdat$StartDateDate5[i]
if(transdat$StatusDate3[i]==1 & transdat$StatusDate4[i]==0) inddd<-transdat$StartDateDate4[i]
if(transdat$StatusDate2[i]==1 & transdat$StatusDate3[i]==0) inddd<-transdat$StartDateDate3[i]
if(transdat$StatusDate1[i]==1 & transdat$StatusDate2[i]==0) inddd<-transdat$StartDateDate2[i]
if(transdat$StatusDate1[i]==0) inddd<-transdat$StartDateDate1[i]
DaysDeath<-c(DaysDeath,inddd)
#for interval censored data, need to specificy that we know it died between which intervals
#If alive on final census, time2=NA, time1=#ofday on last census
if(transdat$StatusDate5[i]==1)time1<-transdat$StartDateDate5[i]
if(transdat$StatusDate5[i]==1)time2<-NA
#If dead on final census, but alive on 4th census, time2=#ofdaydate5, time1=#ofdaydate4
if(transdat$StatusDate5[i]==0 & transdat$StatusDate4[i]==1) time2<-transdat$StartDateDate5[i]
if(transdat$StatusDate5[i]==0 & transdat$StatusDate4[i]==1) time1<-transdat$StartDateDate4[i]
#If dead on 4th census, but alive on 3rd census, time2=#ofdaydate4, time1=#ofdaysondate3
if(transdat$StatusDate3[i]==1 & transdat$StatusDate4[i]==0) time2<-transdat$StartDateDate4[i]
if(transdat$StatusDate3[i]==1 & transdat$StatusDate4[i]==0) time1<-transdat$StartDateDate3[i]
#If dead on 3rd census, but alive on 2nd census, time2=#ofdaydate3, time1=#ofdaysondate2
if(transdat$StatusDate2[i]==1 & transdat$StatusDate3[i]==0) time2<-transdat$StartDateDate3[i]
if(transdat$StatusDate2[i]==1 & transdat$StatusDate3[i]==0) time1<-transdat$StartDateDate2[i]
#If dead on 2nd census, but alive on 1st census, time2=#ofdaydate2, time1=#ofdaysondate1
if(transdat$StatusDate1[i]==1 & transdat$StatusDate2[i]==0) time2<-transdat$StartDateDate2[i]
if(transdat$StatusDate1[i]==1 & transdat$StatusDate2[i]==0) time1<-transdat$StartDateDate1[i]
#If dead on 1st census, time2=#ofdaydate1, time1=14 (all plants checked after 2 weeks and still alive)
if(transdat$StatusDate1[i]==0) time2<-transdat$StartDateDate1[i]
if(transdat$StatusDate1[i]==0) time1<-14
alltime1<-c(alltime1,time1)
alltime2<-c(alltime2,time2)
}
transdat$DaysDeath=DaysDeath
transdat$time1=as.numeric(alltime1)
transdat$time2=alltime2
transdat$allvars <- paste(transdat$CompAmt.1,transdat$PlantedStand, transdat$OriginStand, sep = ".")
##Variable that combines planted elev and competition level, but not origin (for figure 4)
transdat$compelev <- paste(transdat$CompAmt.1,transdat$PlantedStand, sep = ".")
##Variable that combines planted elev and canopy level, but nothing else (for new figure 3)
transdat$canopyelev <- paste(transdat$Canopy,transdat$PlantedStand, sep = ".")
#load in microclimate data and merge with seedling data
tsmedat<-transdat[transdat$Species=="TSME",]
tshedat<-transdat[transdat$Species=="TSHE",]
abamdat<-transdat[transdat$Species=="ABAM",]
tsmedat$PlantedStand=factor(tsmedat$PlantedStand)
tshedat$PlantedStand=factor(tshedat$PlantedStand)
abamdat$PlantedStand=factor(abamdat$PlantedStand)
tsmedat$OriginStand=factor(tsmedat$OriginStand)
tshedat$OriginStand=factor(tshedat$OriginStand)
abamdat$OriginStand=factor(abamdat$OriginStand)
tsmedat$Block=factor(tsmedat$Block)
tshedat$Block=factor(tshedat$Block)
abamdat$Block=factor(abamdat$Block)
tsmedat$allvars=factor(tsmedat$allvars)
tshedat$allvars=factor(tshedat$allvars)
abamdat$allvars=factor(abamdat$allvars)
abamdat$compelev=factor(abamdat$compelev)
tshedat$compelev=factor(tshedat$compelev)
tsmedat$compelev=factor(tsmedat$compelev)
tsmedat$canopyelev=factor(tsmedat$canopyelev)
tshedat$canopyelev=factor(tshedat$canopyelev)
abamdat$canopyelev=factor(abamdat$canopyelev)
